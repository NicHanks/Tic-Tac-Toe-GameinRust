use std::io;

const BOARD_SIZE: usize = 3;

enum Player {
    X,
    O,
}

impl Player {
    fn opposite(&self) -> Player {
        match self {
            Player::X => Player::O,
            Player::O => Player::X,
        }
    }
}

struct Game {
    board: [[Option<Player>; BOARD_SIZE]; BOARD_SIZE],
    current_player: Player,
}

impl Game {
    fn new() -> Game {
        Game {
            board: [[None; BOARD_SIZE]; BOARD_SIZE],
            current_player: Player::X,
        }
    }

    fn display_board(&self) {
        for row in &self.board {
            for cell in row {
                let symbol = match cell {
                    Some(Player::X) => "X",
                    Some(Player::O) => "O",
                    None => " ",
                };
                print!("| {} ", symbol);
            }
            println!("|");
        }
    }

    fn is_valid_move(&self, row: usize, col: usize) -> bool {
        row < BOARD_SIZE && col < BOARD_SIZE && self.board[row][col].is_none()
    }

    fn make_move(&mut self, row: usize, col: usize) {
        if self.is_valid_move(row, col) {
            self.board[row][col] = Some(self.current_player);
            self.current_player = self.current_player.opposite();
        }
    }

    fn check_winner(&self) -> Option<Player> {
        // Check rows
        for row in &self.board {
            if let Some(player) = row[0] {
                if row.iter().all(|&cell| cell == Some(player)) {
                    return Some(player);
                }
            }
        }

        // Check columns
        for col in 0..BOARD_SIZE {
            if let Some(player) = self.board[0][col] {
                if (0..BOARD_SIZE).all(|row| self.board[row][col] == Some(player)) {
                    return Some(player);
                }
            }
        }

        // Check diagonals
        if let Some(player) = self.board[0][0] {
            if (0..BOARD_SIZE).all(|i| self.board[i][i] == Some(player)) {
                return Some(player);
            }
        }
        if let Some(player) = self.board[0][BOARD_SIZE - 1] {
            if (0..BOARD_SIZE).all(|i| self.board[i][BOARD_SIZE - 1 - i] == Some(player)) {
                return Some(player);
            }
        }

        // No winner
        None
    }
}

fn main() {
    let mut game = Game::new();

    println!("Welcome to Tic-Tac-Toe!");

    loop {
        game.display_board();

        println!("Player {:?}'s turn.", game.current_player);

        println!("Enter row and column (0-2) separated by space:");

        let mut input = String::new();
        io::stdin().read_line(&mut input).expect("Failed to read line");

        let mut iter = input.trim().split_whitespace().map(|s| s.parse::<usize>());

        let row = match iter.next() {
            Some(Ok(row)) => row,
            _ => {
                println!("Invalid input! Please enter row and column (0-2) separated by space.");
                continue;
            }
        };

        let col = match iter.next() {
            Some(Ok(col)) => col,
            _ => {
                println!("Invalid input! Please enter row and column (0-2) separated by space.");
                continue;
            }
        };

        if row >= BOARD_SIZE || col >= BOARD_SIZE {
            println!("Invalid input! Row and column must be between 0 and 2.");
            continue;
        }

        if !game.is_valid_move(row, col) {
            println!("Invalid move! Cell already occupied.");
            continue;
        }

        game.make_move(row, col);

        if let Some(winner) = game.check_winner() {
            game.display_board();
            println!("Player {:?} wins!", winner);
            break;
        }

        let board_full = game.board.iter().all(|row| row.iter().all(|cell| cell.is_some()));
        if board_full {
            game.display_board();
            println!("It's a draw!");
            break;
        }
    }
}
